### 计数器（counter）
**一 计数器概念**

计数器计数的是驱动信号的周期数，单位为驱动信号的周期。

**二 设计分析**

如何检测驱动信号经过了一个周期：
通过检测驱动信号的跳变沿来检测驱动信号的周期，检测驱动信号的上升沿或者下降沿来确定驱动信号经过一个周期。

检测上升沿的关键字为：posedge
检测下降沿的关键字为：negedge
假设驱动信号变量名称为：clk

![[Pasted image 20230201125918.png|600]]

posedge clk:表示clk的上升沿触发
negedge rst_n:表示rst_n下降沿触发

描述形式为：
always @(posedge clk,negedge rst_n):异步复位
always @(posedge clk)：同步复位

**异步复位**always @(posedge clk,negedge rst_n)
![[Pasted image 20230201130525.png|600]]
rst_n拉低时，计数恢复到0

**同步复位**always @(posedge clk)
![[Pasted image 20230201130627.png|600]]
rst_n拉低后，clk拉高时，计数恢复到0

同步复位
![[Pasted image 20230201141321.png]]
异步复位
![[Pasted image 20230201141544.png]]

**代码**
```verilog
module counter(
	input clk,
	input rst_n,
	output reg [7:0] count
);

//异步复位

always@(posedge clk,negedge rst_n)begin
	if(rst_n == 0)
		count <= 8'd0;
	else
		if(count < 255)
			count <= count + 8'd1;
		else
			count <= 8'd0;
end

//同步复位
//always@(posedge clk)begin
//	if(rst_n == 0)
//		count <= 8'd0;
//	else
//		if(count < 255)
//			count <= count + 8'd1;
//		else
//			count <= 8'd0;			
//end

endmodule
```

```verilog
`timescale 1ns / 1ps
module counter_tb;
	reg clk;
	reg rst_n;
	wire [7:0] count;
counter counter_inst(
	.clk(clk),
	.rst_n(rst_n),
	.count(count)
);
//模拟时钟信号
initial clk = 1;
always #10 clk = !clk;//延迟10ns跳转一次，一个周期就是20ns

//模拟复位
initial begin
	rst_n = 0;//复位有效
	#200
	rst_n = 1;//置位，复位无效，计数器正常计数
	#6009   //0~255一个周期，每个数间隔20ns,20*256=5120,只要大于5120，就包含一个周期。
	//9在20ns中，用来查看复位信号在一个clk周期内的变化。
	//结论：异步复位在rst_n=0时就变化。同步复位在clk上升沿的时候检测到rst_n=0时才变化。
	rst_n = 0;
	#300
	rst_n = 1;
	#3000
	$stop; //停止。在#3000后加分号无法停止整个程序，always #10 clk = !clk;还在运行
end
endmodule
```